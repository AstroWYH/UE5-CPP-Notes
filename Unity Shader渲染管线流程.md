# Unity Shader渲染管线整理

## 渲染管线

1. **顶点着色器（Vertex Shader）**是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。
2. **曲面细分着色器（Tessellation Shader）**是一个可选的着色器，它用于细分图元。
3. **几何着色器（Geometry Shader）**同样是一个可选的着色器，它可以被用于执行逐图元（Per-Primitive）的着色操作，或者被用于产生更多的图元。
4. 下一个流水线阶段是**裁剪（Clipping）**，这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。这个阶段是可配置的。例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。
5. 几何概念阶段的最后一个流水线阶段是**屏幕映射（Screen Mapping）**。这一阶段是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中。
6. **光栅化（Rasterization ）**概念阶段中的三角形设置（Triangle Setup）和三角形遍历（TriangleTraversal）阶段也都是固定函数（Fixed-Function）的阶段。
7. 接下来的**片元着色器（Fragment Shader）**，则是完全可编程的，它用于实现逐片元（Per-Fragment）的着色操作。
8. 最后，逐片元操作（Per-Fragment Operations）阶段负责执行很多重要的操作，例如**修改颜色、深度缓冲、进行混合**等，它不是可编程的，但具有很高的可配置性。

![image-20220427200218115](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220427200218115.png)

### 1. 概述

由一个三维场景出发，渲染一张二维的图像。

### 2 . 概念渲染流水线

《Real-Time Rendering,Third Edition》将渲染流程划分为三个部分。

**应用阶段** -> **几何阶段** -> **光栅化阶段**

- **应用阶段：**开发者可以自由主导的阶段，通常由 **CPU** 负责。开发者主要通过以下 **3个** 主要任务，输出渲染需要的几何信息，即 **渲染图元**。

- - 布置好场景。模型、相机和光照的摆放。
  - 粗粒度剔除（culling）。将被遮挡，不可见的物体剔除出去。
  - 设置模型的渲染状态。包括材质、纹理、shader等。

- **几何阶段：** 通常在 **GPU** 中进行。对输入的渲染图元进行多步处理，将输出屏幕空间二维顶点坐标，没个顶点包含深度值、着色等信息。

- **光栅化阶段：** 通常在 **GPU** 上运行。主要是决定每一个渲染图元中那些像素应该绘制到屏幕上。需要对几何阶段得到的顶点数据进行插值，然后逐像素处理。

### 3. CPU 和 GPU 之间通信（应用阶段）

应用阶段的起点是 CPU。主要分为三部分。

1. **应用阶段**

2. 1. **把数据加载到显存中：**所有需要渲染的数据，需要从硬盘中加载到内存中，再将网格、纹理等信息加载到 GPU 显存中。
   2. **设置渲染状态：**定义了场景中网格是被怎么渲染的。使用哪个顶点着色器/片元着色器、光源属性、材质等。
   3. **调用 Draw Call：**CPU 通知 GPU 对一个被需要渲染的图元列表进行渲染。

### 4. GPU 流水线（几何阶段 + 光栅化阶段）

![image-20220427202002212](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220427202002212.png)

```c++
我的注释：在每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据、状态和命令等。在这一阶段，CPU需要完成很多工作，例如检查渲染状态等。而一旦CPU完成了这些准备工作，GPU就可以开始本次的渲染。GPU的渲染能力是很强的，渲染200个还是2000个三角网格通常没有什么区别，因此渲染速度往往快于CPU提交命令的速度。如果Draw Call的数量太多，CPU就会把大量时间花费在提交Draw Call上，造成CPU的过载。提交大量很小的Draw Call会造成CPU的性能瓶颈，即CPU把时间都花费在准备Draw Call的工作上了。那么，一个很显然的优化想法就是把很多小的DrawCall合并成一个大的Draw Call，这就是批处理的思想。
```

GPU 接受到了 CPU 的 Draw Call 指令。会按照顺序执行下面的步骤：

1. **几何阶段**

2. 1. **顶点着色器（Vertex Shader）：**完全可编程。顶点变换、着色等功能。
   2. **曲面细分着色器(Tessellation Shader)：**可选着色器，用于细分图元。
   3. **几何着色器(Geometry Shader)：**可选着色器。用于逐图元的着色，或生成更多的图元。
   4. **裁剪(Clipping)：**可配置。将不在摄像机内的顶点裁剪掉，并剔除某些三角图元的面片。
   5. **屏幕映射(Screen Mapping)：**不可配置和编程。负责将图元坐标转换到屏幕坐标系中。

3. **光栅化阶段**

   1. **三角形设置(Triangle Setup)：**固定函数
   2. **三角形遍历(Triangle Traversal)：**固定函数
   3. **片元着色器(Fragment Shader)：**完全可编程。逐片元着色。
   4. **逐片元操作(Per-Fragement Operations)：**可配置。能够修改颜色、深度缓冲、进行混合等。

### 5. 常见问题：OpenGL 和 DirectX

这俩个都是**图像应用编程接口**。应用程序通过这些接口发送渲染命令，接口将把命令发送给**显卡驱动**，驱动将会把命令翻译成 GPU 指令，进行真正的渲染。

OpenGL：左下角为原点（0,0）

DirectX：左上角为原点（0,0）

显卡商为了让显卡支持 OpenGL 和 DirectX，就必须提供支持两个接口的**显卡驱动**。

### 6. 常见问题：HLSL、GLSL、Cg

在可编程渲染管线出来之前，最初是使用汇编进行着色器编码，之后就出现了更高级的着色语言。

- **HLSL(High level Shading Language)：DirectX的着色器语言，**只支持微软**自家平台。**硬件不同，表现相同。**
- **GLSL(OpenGL Shading Language)：OpenGL 的着色器语言，跨平台，但是平台不同，表现不可控**。
- **Cg(C for Graphic)：** NVIDA 推出的着色器语言，跨平台，能和 HLSL 转换。

在 Unity Shader 中，可以选择 “Cg/HLSL” or "GLSL"。

